# Cuckoo Theorem Prover Language

Cuckoo is a theorem prover language based on Lean 4's core language. 

## Use

Run `cargo run -- <file>` to run the type-checker on a file.

## Syntax

```Cuckoo
-- Indictive types are defined using the `data` keyword.
-- Different constructors for the type are then specified. 
-- Constructors can have parameters, including inductive parameters of the type being declared.
data Nat : Type where
  | zero : Nat
  | succ : Nat -> Nat
  
-- Inductive types can have level parameters declared with `.{u}` 
-- and type or value parameters which are specified before the colon.
-- Type and value parameters must be exactly the same wherever they are used in the declaration.
data List.{u} (T : Type u) : Type u where
  | nil : List T
  | cons : T -> List T -> List T

-- Inductive types can also have indices, which come after the colon and are allowed to vary between constructors.
-- The `Vec` type encodes a list of a known length, for example a `Vec.{u} T (Nat.succ Nat.zero)` is guaranteed to have
-- exactly one element.
data Vec.{u} (T : Type u) : Nat -> Type u where
  | nil : Vec T Nat.zero
  | cons : (n : Nat) -> T -> Vec T n -> Vec T (Nat.succ n)

-- The propositional equality type - `Eq T a b` is a proof that `a = b` when a and b have type T
data Eq.{u} (T : Sort u) (x : T) : T -> Prop where
  | refl : Eq T x x

-- Value declarations are made using the `def` keyword. These can have parameters before the colon.
def Nat.add_two (n : Nat) : Nat := Nat.succ (Nat.succ n)

-- This can also be equivalently expressed as the following:
def Nat.add_two' : Nat -> Nat := fun (n : Nat) => Nat.succ (Nat.succ n)
```

## Semantics

Cuckoo is a dependently typed language, meaning that the output type of a function can depend on the value of its input.
For example, consider the following function which constructs a `Vec` of length `n` filled with all zeroes:

```Cuckoo
-- This function works by recursion on `n` using the `Nat.rec` function generated by the kernel
def make_zeroes (n : Nat) : Vec.{0} Nat n := Nat.rec.{1}
    (fun (n : Nat) => Vec.{0} Nat n)
    (Vec.nil.{0} Nat)
    (fun (n : Nat) (v : Vec.{0} Nat n) => Vec.cons.{0} Nat n Nat.zero v)
    n
```

`make_zeroes` has type `(n : Nat) -> Vec.{0} Nat n` - its output type is dependent on the specific value of `n` which is
given as an argument.

### Levels
Every type in Cuckoo has an associated universe level `Sort u` for some natural number `u`, which may depend on its level parameters. The lowest universe 
level is called `Prop` or `Sort 0`, and is where propositions live - these are types that encode mathematical facts rather than being
data such as numbers or lists. This level is treated specially to allow for proof irrelevance and impredicativity.

The next universe is called `Type` or `Sort 1`, and is where most normal data types such as natural numbers live.
Universes above this are rarely used and are reserved for functions and types which are generic over types in lower
universes, for example the function `id : (T : Type) -> T -> T` has universe level `Type 1` because it is
generic over everything in `Type`.

### Recursors
Cuckoo does not have recursive functions (yet), so all functions which wish to perform recursion on one of their arguments
must use the automatically-generated recursor associated with the argument's type. This recursor encodes induction on a 
type as a function which takes as arguments the inductive types parameters, a motive function which specifies the output 
type for any given value of the inductive data type, then rules which say how to construct a value of the motive type 
for each constructor of the inductive type. For examples, the type of the recursor for `Bool` is the following:

```Cuckoo
-- The boolean type
data Bool : Type where
  | true : Bool
  | false: Bool

-- This is the type of the recursor of `Bool` which was generated by the compiler
def bool_rec.{m} :
    (motive : Bool -> Sort m)      -- The motive, which specifies an output type for each value of `Bool`
    -> (true : motive Bool.true)   -- How to construct the motive type if the bool is true
    -> (false : motive Bool.false) -- How to construct the motive type if the bool is false
    -> (b : Bool)                  -- The bool in question
    -> motive b                    -- The recursor returns the motive type for said bool
    := Bool.rec.{m}
```

This recursor can be used to define functions on booleans such as the following:

```Cuckoo
def Bool.not (b : Bool) : Bool := Bool.rec.{1}
    (fun (_: Bool) => Bool) -- No matter the value of b, the output is another bool
    Bool.false              -- If b is true, not b is false
    Bool.true               -- If b is false, not b is true
    b

-- A proof that not (not b) = b
def Bool.not_not (b : Bool) : Eq.{1} Bool (Bool.not (Bool.not b)) b := Bool.rec.{0}
    (fun (b : Bool) => Eq.{1} Bool (Bool.not (Bool.not b)) b) -- For some input bool `b`, we are constructing a value of type `not (not b) = b)`
    (Eq.refl.{1} Bool Bool.true)                              -- not (not true) = true by reflexivity, because the kernel can calculate not (not true)
    (Eq.refl.{1} Bool Bool.false)                             -- not (not false) = false by reflexivity, because the kernel can calculate not (not false)
    b
```

See the `examples` directory for more examples of how to declare functions and data types.

## Planned features
* Type inference
* Implicit parameters
* Recursive definitions, compiled into either structural or well-founded recursive definitions
* Mutually recursive definitions
* Procedural programming